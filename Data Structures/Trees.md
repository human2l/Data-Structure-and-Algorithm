<img src="Trees.assets/Screen Shot 2022-01-30 at 10.40.18 PM.png" alt="Screen Shot 2022-01-30 at 10.40.18 PM" style="zoom:25%;" />

# Binary Tree

<img src="Trees.assets/Screen Shot 2022-01-30 at 11.23.40 PM.png" alt="Screen Shot 2022-01-30 at 11.23.40 PM" style="zoom:25%;" />

## Perfect Binary Tree

* have all the leaf nodes

* number of nodes doubles on each level

* numbers of nodes of last level = numbers of nodes of all other levels + 1

## Full Binary Tree

* 0 or 2 children, cannot have 1 child

# Binary Search Tree

<img src="Trees.assets/Screen Shot 2022-01-31 at 10.42.14 AM.png" alt="Screen Shot 2022-01-31 at 10.42.14 AM" style="zoom:50%;" />

## Balanced BST

<img src="Trees.assets/Screen Shot 2022-01-30 at 11.36.27 PM.png" alt="Screen Shot 2022-01-30 at 11.36.27 PM" style="zoom:25%;" />

left < current < right

### AVL Tree & Red Black Tree

* Balanced Tree

* Automatically rebalance the tree after new item inserted

## Unbalanced BST

<img src="Trees.assets/Screen Shot 2022-01-31 at 10.37.43 AM.png" alt="Screen Shot 2022-01-31 at 10.37.43 AM" style="zoom:25%;" />

In extreme case, unbalanced BST become linked list

# Binary Heap

<img src="Trees.assets/Screen Shot 2022-01-31 at 3.38.37 PM.png" alt="Screen Shot 2022-01-31 at 3.38.37 PM" style="zoom:50%;" />

Max Heap (root node is largest)

Min Heap (root node is smallest)

`findMax()` or `findMin()`: O(1)

<img src="Trees.assets/Screen Shot 2022-01-31 at 4.17.33 PM.png" alt="Screen Shot 2022-01-31 at 4.17.33 PM" style="zoom:50%;" />

### Usage

easy to filter the large/small data

data storage, priority queue, sorting algorithm

## Priority Queue

make the highest priority item to the top, least priority items on bottom

# Trie

<img src="Trees.assets/Screen Shot 2022-01-31 at 4.20.53 PM.png" alt="Screen Shot 2022-01-31 at 4.20.53 PM" style="zoom:50%;" />

Works like auto completion on google searchbar, or it can be used on IP routing

O(length of the word)

Save space: save N, O, T instead of the word "not"

